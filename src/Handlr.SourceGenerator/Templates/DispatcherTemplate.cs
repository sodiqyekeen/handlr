using System.Collections.Generic;
using System.Linq;
using System.Text;
using Handlr.SourceGenerator.Models;

namespace Handlr.SourceGenerator.Templates;

/// <summary>
/// Template for generating the enhanced switch-based dispatcher
/// </summary>
public static class DispatcherTemplate
{
    /// <summary>
    /// Generates the enhanced HandlrDispatcher implementation using switch expressions
    /// </summary>
    /// <param name="commands">List of discovered commands</param>
    /// <param name="queries">List of discovered queries</param>
    /// <param name="includeDebugInfo">Whether to include debug information</param>
    /// <returns>The generated dispatcher code</returns>
    public static string Generate(
        IEnumerable<CommandInfo> commands,
        IEnumerable<QueryInfo> queries,
        bool includeDebugInfo = false)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        if (includeDebugInfo)
        {
            sb.AppendLine("// Generated Handlr dispatcher using switch expressions for optimal performance");
        }
        sb.AppendLine();

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Handlr.Abstractions.Commands;");
        sb.AppendLine("using Handlr.Abstractions.Queries;");
        sb.AppendLine("using Handlr.Abstractions.Common;");
        sb.AppendLine("using Handlr.Abstractions.Pipelines;");

        // Add using statements for all command and query namespaces
        var namespaces = new HashSet<string>();
        foreach (var command in commands)
        {
            namespaces.Add(command.Namespace);
        }
        foreach (var query in queries)
        {
            namespaces.Add(query.Namespace);
        }
        foreach (var ns in namespaces.OrderBy(x => x))
        {
            sb.AppendLine($"using {ns};");
        }
        sb.AppendLine();

        sb.AppendLine("namespace Handlr.Generated;");
        sb.AppendLine();

        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// High-performance dispatcher implementation using switch expressions and pipeline integration.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal sealed class GeneratedHandlrDispatcher : IHandlrDispatcher");
        sb.AppendLine("{");
        sb.AppendLine("    private readonly IServiceProvider _serviceProvider;");
        sb.AppendLine();
        sb.AppendLine("    public GeneratedHandlrDispatcher(IServiceProvider serviceProvider)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate SendAsync for commands without result
        GenerateSendCommandMethod(sb, commands);

        // Generate SendAsync for commands with result
        GenerateSendCommandWithResultMethod(sb, commands);

        // Generate SendAsync for queries
        GenerateSendQueryMethod(sb, queries);

        // Generate individual handler methods
        GenerateHandlerMethods(sb, commands, queries);

        // Generate pipeline execution method
        GeneratePipelineExecutionMethod(sb);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateSendCommandMethod(StringBuilder sb, IEnumerable<CommandInfo> commands)
    {
        var commandsWithoutResult = commands.Where(c => !c.HasResult);

        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public Task SendAsync<TCommand>(TCommand command, CancellationToken cancellationToken = default)");
        sb.AppendLine("        where TCommand : ICommand");
        sb.AppendLine("    {");
        sb.AppendLine("        if (command == null) throw new ArgumentNullException(nameof(command));");
        sb.AppendLine();

        if (commandsWithoutResult.Any())
        {
            sb.AppendLine("        return command switch");
            sb.AppendLine("        {");

            foreach (var command in commandsWithoutResult)
            {
                var methodName = $"Handle{command.Name}";
                sb.AppendLine($"            {command.Name} cmd => {methodName}(cmd, cancellationToken),");
            }

            sb.AppendLine("            _ => throw new NotSupportedException($\"Command type {command.GetType().Name} is not supported.\")");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        return Task.FromException(new NotSupportedException($\"Command type {command.GetType().Name} is not supported.\"));");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateSendCommandWithResultMethod(StringBuilder sb, IEnumerable<CommandInfo> commands)
    {
        var commandsWithResult = commands.Where(c => c.HasResult);

        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public async Task<TResult> SendAsync<TResult>(ICommand<TResult> command, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (command == null) throw new ArgumentNullException(nameof(command));");
        sb.AppendLine();

        if (commandsWithResult.Any())
        {
            sb.AppendLine("        return command switch");
            sb.AppendLine("        {");

            foreach (var command in commandsWithResult)
            {
                var methodName = $"Handle{command.Name}";
                sb.AppendLine($"            {command.Name} cmd => (TResult)(object)await {methodName}(cmd, cancellationToken),");
            }

            sb.AppendLine("            _ => throw new NotSupportedException($\"Command type {command.GetType().Name} is not supported.\")");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        throw new NotSupportedException($\"Command type {command.GetType().Name} is not supported.\");");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateSendQueryMethod(StringBuilder sb, IEnumerable<QueryInfo> queries)
    {
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    public async Task<TResult> SendAsync<TResult>(IQuery<TResult> query, CancellationToken cancellationToken = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (query == null) throw new ArgumentNullException(nameof(query));");
        sb.AppendLine();

        if (queries.Any())
        {
            sb.AppendLine("        return query switch");
            sb.AppendLine("        {");

            foreach (var query in queries)
            {
                var methodName = $"Handle{query.Name}";
                sb.AppendLine($"            {query.Name} qry => (TResult)(object)await {methodName}(qry, cancellationToken),");
            }

            sb.AppendLine("            _ => throw new NotSupportedException($\"Query type {query.GetType().Name} is not supported.\")");
            sb.AppendLine("        };");
        }
        else
        {
            sb.AppendLine("        throw new NotSupportedException($\"Query type {query.GetType().Name} is not supported.\");");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateHandlerMethods(StringBuilder sb, IEnumerable<CommandInfo> commands, IEnumerable<QueryInfo> queries)
    {
        // Generate command handler methods
        foreach (var command in commands)
        {
            var methodName = $"Handle{command.Name}";

            if (command.HasResult)
            {
                var resultType = command.ResultType?.ToDisplayString() ?? "object";
                sb.AppendLine($"    private async Task<{resultType}> {methodName}({command.Name} command, CancellationToken cancellationToken)");
                sb.AppendLine("    {");
                sb.AppendLine($"        return await ExecutePipeline<{command.Name}, {resultType}>(command, async () => {{");
                sb.AppendLine($"            var handler = _serviceProvider.GetRequiredService<ICommandHandler<{command.Name}, {resultType}>>();");
                sb.AppendLine("            return await handler.Handle(command, cancellationToken);");
                sb.AppendLine("        }, cancellationToken);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
            else
            {
                sb.AppendLine($"    private async Task {methodName}({command.Name} command, CancellationToken cancellationToken)");
                sb.AppendLine("    {");
                sb.AppendLine($"        await ExecutePipelineVoid<{command.Name}>(command, async () => {{");
                sb.AppendLine($"            var handler = _serviceProvider.GetRequiredService<ICommandHandler<{command.Name}>>();");
                sb.AppendLine("            await handler.Handle(command, cancellationToken);");
                sb.AppendLine("        }, cancellationToken);");
                sb.AppendLine("    }");
                sb.AppendLine();
            }
        }

        // Generate query handler methods
        foreach (var query in queries)
        {
            var methodName = $"Handle{query.Name}";
            var resultType = query.ResultType.ToDisplayString();

            sb.AppendLine($"    private async Task<{resultType}> {methodName}({query.Name} query, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine($"        return await ExecutePipeline<{query.Name}, {resultType}>(query, async () => {{");
            sb.AppendLine($"            var handler = _serviceProvider.GetRequiredService<IQueryHandler<{query.Name}, {resultType}>>();");
            sb.AppendLine("            return await handler.Handle(query, cancellationToken);");
            sb.AppendLine("        }, cancellationToken);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static void GeneratePipelineExecutionMethod(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Executes pipeline behaviors for requests with results.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private async Task<TResult> ExecutePipeline<TRequest, TResult>(");
        sb.AppendLine("        TRequest request,");
        sb.AppendLine("        Func<Task<TResult>> handlerFunc,");
        sb.AppendLine("        CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Get all registered behaviors for this request/result type combination");
        sb.AppendLine("        var behaviors = _serviceProvider.GetServices<IPipelineBehavior<TRequest, TResult>>();");
        sb.AppendLine();
        sb.AppendLine("        if (!behaviors.Any())");
        sb.AppendLine("        {");
        sb.AppendLine("            return await handlerFunc();");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Build the pipeline chain dynamically based on registered behaviors");
        sb.AppendLine("        // Behaviors execute in registration order");
        sb.AppendLine("        var pipeline = behaviors.Reverse().Aggregate(");
        sb.AppendLine("            (RequestHandlerDelegate<TResult>)(() => handlerFunc()),");
        sb.AppendLine("            (next, behavior) => (RequestHandlerDelegate<TResult>)(() => behavior.Handle(request, next, cancellationToken))");
        sb.AppendLine("        );");
        sb.AppendLine();
        sb.AppendLine("        return await pipeline();");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Executes pipeline behaviors for requests without results (void commands).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private async Task ExecutePipelineVoid<TRequest>(");
        sb.AppendLine("        TRequest request,");
        sb.AppendLine("        Func<Task> handlerFunc,");
        sb.AppendLine("        CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Get all registered behaviors for this request/Unit type combination");
        sb.AppendLine("        var behaviors = _serviceProvider.GetServices<IPipelineBehavior<TRequest, Unit>>();");
        sb.AppendLine();
        sb.AppendLine("        if (!behaviors.Any())");
        sb.AppendLine("        {");
        sb.AppendLine("            await handlerFunc();");
        sb.AppendLine("            return;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        // Build the pipeline chain dynamically based on registered behaviors");
        sb.AppendLine("        var pipeline = behaviors.Reverse().Aggregate(");
        sb.AppendLine("            (RequestHandlerDelegate<Unit>)(async () => { await handlerFunc(); return Unit.Value; }),");
        sb.AppendLine("            (next, behavior) => (RequestHandlerDelegate<Unit>)(async () => await behavior.Handle(request, next, cancellationToken))");
        sb.AppendLine("        );");
        sb.AppendLine();
        sb.AppendLine("        await pipeline();");
        sb.AppendLine("    }");
    }
}
