using System.Text;
using Handlr.SourceGenerator.Models;

namespace Handlr.SourceGenerator.Templates;

/// <summary>
/// Template for generating command handlers with pipeline support.
/// </summary>
public static class CommandHandlerTemplate
{
    /// <summary>
    /// Generates a command handler class with pipeline behavior integration.
    /// </summary>
    /// <param name="commandInfo">Information about the command</param>
    /// <param name="includeDebugInfo">Whether to include debug information</param>
    /// <returns>The generated command handler code</returns>
    public static string Generate(CommandInfo commandInfo, bool includeDebugInfo = false)
    {
        var sb = new StringBuilder();

        if (includeDebugInfo)
        {
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine($"// Generated for command: {commandInfo.FullName}");
            sb.AppendLine($"// Has result: {commandInfo.HasResult}");
            sb.AppendLine($"// Result type: {commandInfo.ResultType?.ToDisplayString() ?? "void"}");
            sb.AppendLine();
        }

        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Handlr.Abstractions.Commands;");
        sb.AppendLine("using Handlr.Abstractions.Pipelines;");
        sb.AppendLine("using Handlr.Abstractions.Results;");
        sb.AppendLine("using Handlr.Abstractions.Common;");
        sb.AppendLine();

        sb.AppendLine($"namespace {commandInfo.Namespace};");
        sb.AppendLine();

        // Generate the handler class
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated handler for {commandInfo.Name} command with pipeline support.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public partial class {commandInfo.GeneratedHandlerName} : {commandInfo.HandlerInterfaceName}");
        sb.AppendLine("{");

        // Private fields
        sb.AppendLine("    private readonly IServiceProvider _serviceProvider;");
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"    private readonly IEnumerable<IPipelineBehavior<{commandInfo.Name}, {commandInfo.ResultType?.ToDisplayString()}>> _behaviors;");
        }
        else
        {
            sb.AppendLine($"    private readonly IEnumerable<IPipelineBehavior<{commandInfo.Name}, Unit>> _behaviors;");
        }
        sb.AppendLine();

        // Constructor
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Initializes a new instance of the {commandInfo.GeneratedHandlerName} class.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"serviceProvider\">The service provider</param>");
        sb.AppendLine($"    public {commandInfo.GeneratedHandlerName}(IServiceProvider serviceProvider)");
        sb.AppendLine("    {");
        sb.AppendLine("        _serviceProvider = serviceProvider ?? throw new ArgumentNullException(nameof(serviceProvider));");
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"        _behaviors = serviceProvider.GetServices<IPipelineBehavior<{commandInfo.Name}, {commandInfo.ResultType?.ToDisplayString()}>>() ?? Enumerable.Empty<IPipelineBehavior<{commandInfo.Name}, {commandInfo.ResultType?.ToDisplayString()}>>();");
        }
        else
        {
            sb.AppendLine($"        _behaviors = serviceProvider.GetServices<IPipelineBehavior<{commandInfo.Name}, Unit>>() ?? Enumerable.Empty<IPipelineBehavior<{commandInfo.Name}, Unit>>();");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        // Handle method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Handles the command with pipeline behavior execution.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"command\">The command to handle</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation</returns>");
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"    public async Task<{commandInfo.ResultType?.ToDisplayString()}> Handle({commandInfo.Name} command, CancellationToken cancellationToken = default)");
        }
        else
        {
            sb.AppendLine($"    public async Task Handle({commandInfo.Name} command, CancellationToken cancellationToken = default)");
        }
        sb.AppendLine("    {");
        sb.AppendLine("        if (command == null)");
        sb.AppendLine("            throw new ArgumentNullException(nameof(command));");
        sb.AppendLine();

        if (commandInfo.HasResult)
        {
            sb.AppendLine("        return await ExecutePipeline(command, () => HandleCore(command, cancellationToken), cancellationToken);");
        }
        else
        {
            sb.AppendLine("        await ExecutePipelineVoid(command, () => HandleCoreVoid(command, cancellationToken), cancellationToken);");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        // Pipeline execution method
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"    private async Task<{commandInfo.ResultType?.ToDisplayString()}> ExecutePipeline({commandInfo.Name} command, RequestHandlerDelegate<{commandInfo.ResultType?.ToDisplayString()}> next, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (!_behaviors.Any())");
            sb.AppendLine("        {");
            sb.AppendLine("            return await next();");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        var behaviorIndex = 0;");
            sb.AppendLine("        var orderedBehaviors = _behaviors.OrderBy(b => GetBehaviorPriority(b)).ToList();");
            sb.AppendLine();
            sb.AppendLine($"        async Task<{commandInfo.ResultType?.ToDisplayString()}> ExecuteNextBehavior()");
            sb.AppendLine("        {");
            sb.AppendLine("            if (behaviorIndex >= orderedBehaviors.Count)");
            sb.AppendLine("            {");
            sb.AppendLine("                return await next();");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            var behavior = orderedBehaviors[behaviorIndex++];");
            sb.AppendLine("            return await behavior.Handle(command, ExecuteNextBehavior, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        return await ExecuteNextBehavior();");
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    private async Task ExecutePipelineVoid({commandInfo.Name} command, RequestHandlerDelegate<Unit> next, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (!_behaviors.Any())");
            sb.AppendLine("        {");
            sb.AppendLine("            await next();");
            sb.AppendLine("            return;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        var behaviorIndex = 0;");
            sb.AppendLine("        var orderedBehaviors = _behaviors.OrderBy(b => GetBehaviorPriority(b)).ToList();");
            sb.AppendLine();
            sb.AppendLine("        async Task<Unit> ExecuteNextBehavior()");
            sb.AppendLine("        {");
            sb.AppendLine("            if (behaviorIndex >= orderedBehaviors.Count)");
            sb.AppendLine("            {");
            sb.AppendLine("                return await next();");
            sb.AppendLine("            }");
            sb.AppendLine();
            sb.AppendLine("            var behavior = orderedBehaviors[behaviorIndex++];");
            sb.AppendLine("            return await behavior.Handle(command, ExecuteNextBehavior, cancellationToken);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        await ExecuteNextBehavior();");
            sb.AppendLine("    }");
        }
        sb.AppendLine();

        // Core handler method (to be implemented by user)
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"    private async Task<{commandInfo.ResultType?.ToDisplayString()}> HandleCore({commandInfo.Name} command, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine("        var result = await HandleAsync(command, cancellationToken);");
            sb.AppendLine("        return result;");
            sb.AppendLine("    }");
        }
        else
        {
            // Add both HandleCore that returns Unit and HandleCoreVoid that's used by pipeline
            sb.AppendLine($"    private async Task<Unit> HandleCore({commandInfo.Name} command, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine("        await HandleAsync(command, cancellationToken);");
            sb.AppendLine("        return Unit.Value;");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine($"    private async Task<Unit> HandleCoreVoid({commandInfo.Name} command, CancellationToken cancellationToken)");
            sb.AppendLine("    {");
            sb.AppendLine("        await HandleAsync(command, cancellationToken);");
            sb.AppendLine("        return Unit.Value;");
            sb.AppendLine("    }");
        }
        sb.AppendLine();

        // Behavior priority helper
        sb.AppendLine("    private static int GetBehaviorPriority(object behavior)");
        sb.AppendLine("    {");
        sb.AppendLine("        // Check for priority attributes or interfaces");
        sb.AppendLine("        var type = behavior.GetType();");
        sb.AppendLine("        // Default priority is 100");
        sb.AppendLine("        return 100;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Partial method for user implementation
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Implement this method to provide the command handling logic.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"command\">The command to handle</param>");
        sb.AppendLine("    /// <param name=\"cancellationToken\">Cancellation token</param>");
        sb.AppendLine("    /// <returns>A task representing the asynchronous operation</returns>");
        if (commandInfo.HasResult)
        {
            sb.AppendLine($"    public partial Task<{commandInfo.ResultType?.ToDisplayString()}> HandleAsync({commandInfo.Name} command, CancellationToken cancellationToken);");
        }
        else
        {
            sb.AppendLine($"    public partial Task HandleAsync({commandInfo.Name} command, CancellationToken cancellationToken);");
        }

        sb.AppendLine("}");

        // Unit type for void commands (if needed)
        if (!commandInfo.HasResult)
        {
            sb.AppendLine();
            sb.AppendLine("/// <summary>");
            sb.AppendLine("/// Represents a void return type for commands without results.");
            sb.AppendLine("/// </summary>");
            sb.AppendLine("public readonly struct Unit");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Gets the singleton instance of Unit.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static Unit Value { get; } = new();");
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}
